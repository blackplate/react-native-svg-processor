const fs = require('fs').promises;
const path = require('path');
const camelCase = require('camelcase');
const svgr = require('@svgr/core').transform;
const glob = require('glob');

const fileTemplate = ({ imports, componentName, props, jsx, exports }, { tpl }) => {
  // Use imports instead of Manual, imports need to be sorted though.
  return tpl`
    // AUTOGENERATED DO NOT EDIT
    import React from 'react';
    import Svg, { Path, SvgProps } from 'react-native-svg';
    const ${componentName} = (${props}) => ${jsx};
    export default React.memo(${componentName});
  `;
};

const prettierConfig = {
  useTabs: false,
  bracketSpacing: false,
  trailingComma: 'all',
  arrowParens: 'avoid',
  singleQuote: true,
};

async function processFiles(srcFiles, outputPath) {
  const files = await new Promise((resolve, reject) => {
    glob(`${srcFiles.toString()}/**/*.svg`, (err, files) => {
      if (err) {
        reject(err);
      } else {
        resolve(files);
      }
    });
  });

  for (const file of files) {
    const basename = path.basename(file);
    const [name] = basename.split('.');
    const componentName = camelCase(name, { pascalCase: true });
    const svgCode = await fs.readFile(file, 'utf8');

    const jsCode = await svgr(
      svgCode,
      {
        plugins: [
          '@svgr/plugin-svgo',
          '@svgr/plugin-jsx',
          '@svgr/plugin-prettier',
        ],
        template: fileTemplate,
        native: true,
        typescript: true,
        // standard color should be overwritable
        replaceAttrValues: { '#000': 'currentColor' },
        prettierConfig,
        svgoConfig: {
          multipass: true,
          plugins: [
            {
              name: 'preset-default',
              params: {
                overrides: {
                  removeViewBox: false,
                },
              },
            },
            'removeXMLNS',
          ],
        },
      },
      { componentName }
    );

    const filePath = path.join(outputPath.toString(), `${componentName}.tsx`);
    await fs.writeFile(filePath, jsCode, 'utf8');
    console.log(`Processed ${filePath}`);
  }
}

async function saveIndexFile(outputPath) {
  const indexFilePath = path.join(outputPath, 'index.ts');

  const files = await fs.readdir(outputPath);

  const tsxFiles = files.filter((file) => /\.tsx$/i.test(file));

  const importStatements = tsxFiles.map((file) => {
    const [name] = file.split('.');
    return `import ${camelCase(name, { pascalCase: true })} from './${name}';`;
  });

  const exportStatement = `export { ${tsxFiles
    .map((file) => camelCase(file.split('.')[0], { pascalCase: true }))
    .join(', ')} };`;

  const indexFile = `${importStatements.join('\n')}\n${exportStatement}\n`;

  await fs.writeFile(indexFilePath, indexFile, 'utf8');
  console.log('Index saved');
}

async function process(src, out) {
  try {
    await processFiles(src, out);
    await saveIndexFile(out);
  } catch (error) {
    console.error('An error occurred:', error);
  }
}

module.exports = {
  process,
};
